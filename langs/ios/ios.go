package ios

import (
	"fmt"
	"text/template"

	"github.com/iancoleman/strcase"
	"github.com/mickeyreiss/firemodel"
	"github.com/pkg/errors"
	"strings"
)

func init() {
	firemodel.RegisterModeler("ios", &Modeler{})
}

type Modeler struct{}

func (m *Modeler) Model(schema *firemodel.Schema, sourceCoder firemodel.SourceCoder) error {
	f, err := sourceCoder.NewFile("firemodel.swift")
	if err != nil {
		return errors.Wrapf(err, "firemodel/ios: create swift file")
	}
	defer f.Close()

	if err := tpl.Execute(f, schema); err != nil {
		return errors.Wrapf(err, "firemodel/ios: generating swift")
	}
	return nil
}

var (
	tpl = template.Must(template.
		New("file").
		Funcs(map[string]interface{}{
			"toSwiftType":                    toSwiftType,
			"toScreamingSnake":               strcase.ToScreamingSnake,
			"toLowerCamel":                   strcase.ToLowerCamel,
			"filterFieldsEnumsOnly":          filterFieldsEnumsOnly,
			"asStaticConfigForFirestorePath": asStaticConfigForFirestorePath,
		}).
		Parse(file),
	)
	_ = template.Must(tpl.New("model").Parse(model))
	_ = template.Must(tpl.New("enum").Parse(enum))
)

func filterFieldsEnumsOnly(in []*firemodel.SchemaField) []*firemodel.SchemaField {
	var out []*firemodel.SchemaField
	for _, i := range in {
		if i.Extras == nil || i.Extras.EnumType == "" {
			continue
		}
		out = append(out, i)
	}
	return out
}

func toSwiftType(extras *firemodel.SchemaFieldExtras, root bool, firetype firemodel.SchemaFieldType) string {
	switch firetype {
	case firemodel.Boolean:
		return "Bool = false"
	case firemodel.Integer:
		return "Int = 0"
	case firemodel.Double:
		return "Float = 0.0"
	case firemodel.Timestamp:
		return "Date = Date()"
	case firemodel.String:
		if extras != nil && extras.EnumType != "" {
			return extras.EnumType
		} else if extras != nil && extras.URL {
			if root {
				return "URL?"
			} else {
				return "URL"
			}
		} else {
			if root {
				return "String?"
			} else {
				return "String"
			}
		}
	case firemodel.Bytes:
		if root {
			return "Data?"
		} else {
			return "Data"
		}
	case firemodel.Reference:
		if extras != nil && extras.ReferenceTo != "" {
			return fmt.Sprintf("Pring.Reference<%s> = .init()", extras.ReferenceTo)
		} else {
			return "Pring.AnyReference"
		}
	case firemodel.GeoPoint:
		return "Pring.GeoPoint"
	case firemodel.Array:
		if extras != nil && extras.ArrayOf != "" {
			return fmt.Sprintf("[%s] = []", extras.ArrayOf)
		} else if extras != nil && extras.ArrayOfPrimitive != "" {
			return fmt.Sprintf("[%s] = []", toSwiftType(nil,false, extras.ArrayOfPrimitive))
		} else {
			return "[Any]"
		}
	case firemodel.Map:
		if extras != nil && extras.File {
			return "Pring.File"
		} else if extras != nil && extras.MapTo != "" {
			return fmt.Sprintf("[String: %s] = [:]", extras.MapTo)
		} else if extras != nil && extras.MapToPrimitive != "" {
			return fmt.Sprintf("[String: %s] = [:]", toSwiftType(nil, false,extras.MapToPrimitive))
		} else {
			return "[AnyHashable: Any] = []"
		}
	default:
		err := errors.Errorf("firemodel/ios: unknown type %s", firetype)
		panic(err)
	}
}

func asStaticConfigForFirestorePath(options firemodel.SchemaModelOptions) string {
	format, args, err := options.GetFirestorePath()
	if err != nil {
		panic(err)
	}
	var out strings.Builder

	for _, arg := range args {
		fmt.Fprintf(&out, "static var %s: String = \"\"\n", strcase.ToLowerCamel(arg))
	}

	argsWrappedInInterpolationParens := make([]interface{}, len(args))
	for idx, arg := range args {
		argsWrappedInInterpolationParens[idx] = fmt.Sprintf(`\(%s)`, strcase.ToLowerCamel(arg))
	}
	path := fmt.Sprintf(format, argsWrappedInInterpolationParens...)

	fmt.Fprintf(&out, "    override class var path: String { return \"%s\" }\n", path)

	return out.String()
}

const (
	file = `// DO NOT EDIT - Code generated by firemodel.

import Foundation
import Pring
{{range .Enums -}}
{{template "enum" .}}
{{- end}}
{{- range .Models -}}
{{- template "model" .}}
{{- end -}}`

	model = `
{{- if .Comment}}
// {{.Comment}}
{{- else}}
// TODO: Add documentation to {{.Name}}.
{{- end}}
@objcMembers class {{.Name}}: Pring.Object {
    {{.Options | asStaticConfigForFirestorePath -}}
    {{- range .Fields}}
    {{- if .Comment}}
    // {{.Comment}}
    {{- else }}
    // TODO: Add documentation to {{.Name}}.
    {{- end}}
    dynamic var {{.Name | toLowerCamel -}}: {{.Type | toSwiftType .Extras true}}
    {{- end}}

    {{- range .Collections}}
    {{- if .Comment}}
    // {{.Comment}}
    {{- else }}
    // TODO: Add documentation to {{.Name}}.
    {{- end}}
    {{.Name}}: Pring.NestedCollection<{{.Type}}>
    {{- end}}

    override func encode(_ key: String, value: Any?) -> Any? {
        switch key {
        {{range .Fields | filterFieldsEnumsOnly -}}
        case "{{.Name | toLowerCamel}}":
            return self.{{.Name | toLowerCamel}}.rawValue
            {{- end}}
        default:
            break
        }
        return nil
    }

    override func decode(_ key: String, value: Any?) -> Bool {
        switch key {
        {{range .Fields | filterFieldsEnumsOnly -}}
        case "{{.Name | toLowerCamel}}":
            if let value = value as? String, let {{.Name | toLowerCamel}} = {{.Type}}(rawValue: value) {
                self.{{.Name | toLowerCamel}} = {{.Name | toLowerCamel}}
                return true
            }
            {{- end}}
        default:
            break
        }
        return false
    }
}
`
	enum = `
{{- if .Comment}}
// {{.Comment}}
{{- else}}
// TODO: Add documentation to {{.Name}}.
{{- end}}
@objc enum {{.Name}}: String {
    {{- range .Values}}
    {{- if .Comment}}
    // {{.Comment}}
    {{- else}}
    // TODO: Add documentation to {{.Name}}.
    {{- end}}
    case {{.Name}} = "{{.Name | toScreamingSnake}}"
    {{- end}}
}
`
)
